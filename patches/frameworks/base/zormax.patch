commit 184881d2795e679aa39491ff340a48c670d7d522
Author: tribual <tribual@web.de>
Date:   Wed Nov 29 10:25:52 2017 +0100

    base-patch-zormax
    
    Change-Id: If1152b9bb10cef6982980e9929c21ab9495baeb5

diff --git a/core/jni/android_media_AudioSystem.cpp b/core/jni/android_media_AudioSystem.cpp
index 4976002..8133ffb 100644
--- a/core/jni/android_media_AudioSystem.cpp
+++ b/core/jni/android_media_AudioSystem.cpp
@@ -1743,6 +1743,136 @@ android_media_AudioSystem_systemReady(JNIEnv *env, jobject thiz)
     return nativeToJavaStatus(AudioSystem::systemReady());
 }
 
+// zormax add
+static int
+android_media_AudioSystem_GetAudioData(JNIEnv *env, jobject thiz,jint par ,jint len,jbyteArray javaEmParamter)
+{
+    int index = 0;
+    char buffer[len] ;
+    // get the pointer for the audio data from the java array
+    jbyte* AudioCustomVolumeParameter = NULL;
+    memset(buffer, 0, len);
+    if (javaEmParamter) {
+        AudioCustomVolumeParameter = (jbyte *)env->GetByteArrayElements(javaEmParamter, NULL);
+        if (AudioCustomVolumeParameter == NULL) {
+            ALOGE("Error retrieving source of EM paramters");
+            return -2; // out of memory or no data to load
+        }
+    } else {
+        ALOGE("NULL java array of audio data to play, can't play");
+        return -2;
+    }
+    if(AudioSystem::GetAudioData(par,len,(void *)buffer) != NO_ERROR ){
+        index =-1;
+    }
+    env->SetByteArrayRegion(javaEmParamter, 0, len, (const signed char*) buffer);
+    env->ReleaseByteArrayElements(javaEmParamter, AudioCustomVolumeParameter, JNI_ABORT);
+    return index;
+}
+
+static int
+android_media_AudioSystem_SetEMParameter(JNIEnv *env, jobject thiz, jbyteArray javaEmParamter, jint len)
+{
+    int index = 0;
+    // get the pointer for the audio data from the java array
+    jbyte* EMParameter = NULL;
+    if (javaEmParamter) {
+        EMParameter = (jbyte *)env->GetByteArrayElements(javaEmParamter, NULL);
+        if (EMParameter == NULL) {
+            ALOGE("Error retrieving source of EM paramters");
+            return -2; // out of memory or no data to load
+        }
+    } else {
+        ALOGE("NULL java array of audio data to play, can't play");
+        return -2;
+    }
+    if(AudioSystem::SetEMParameter ((void *)EMParameter, len) != NO_ERROR ){
+        index =-1;
+    }
+
+    env->ReleaseByteArrayElements(javaEmParamter, EMParameter, JNI_ABORT);
+
+    return index;
+}
+
+static int
+android_media_AudioSystem_SetAudioData(JNIEnv *env, jobject thiz, jint par,jint len, jbyteArray javaEmParamter)
+{
+    int index = 0;
+    // get the pointer for the audio data from the java array
+    jbyte* AudioCustomVolumeParameter = NULL;
+    if (javaEmParamter) {
+        AudioCustomVolumeParameter = (jbyte *)env->GetByteArrayElements(javaEmParamter, NULL);
+        if (AudioCustomVolumeParameter == NULL) {
+            ALOGE("Error retrieving source of  AudioCustomVolumeParameter");
+            return -2; // out of memory or no data to load
+        }
+    } else {
+        ALOGE("NULL java array of audio data to play, can't play");
+        return -2;
+    }
+    if(AudioSystem::SetAudioData (par,len,(void *)AudioCustomVolumeParameter) != NO_ERROR ){
+        index =-1;
+    }
+    env->ReleaseByteArrayElements(javaEmParamter, AudioCustomVolumeParameter, JNI_ABORT);
+    return index;
+}
+
+
+static int
+android_media_AudioSystem_SetAudioCommandX(JNIEnv *env, jobject thiz, jint para1, jint para2)
+{
+    int ret = 0;
+    if(PERMISSION_DENIED == (ret = AudioSystem::SetAudioCommand(para1, para2)))
+        {
+            return -1;
+        }
+        else
+            {
+                return ret;
+            }
+
+}
+
+static int
+android_media_AudioSystem_GetAudioCommandX(JNIEnv *env, jobject thiz, jint para1)
+{
+    int ret = -1;
+    if(NO_ERROR != AudioSystem::GetAudioCommand(para1, &ret))
+    {
+        return -1;
+    }
+    return ret;
+}
+
+static int
+android_media_AudioSystem_GetEMParameter(JNIEnv *env, jobject thiz, jbyteArray javaEmParamter, jint len)
+{
+    int index = 0;
+    // get the pointer for the audio data from the java array
+    jbyte* EMParameter = NULL;
+    char buffer[len] ;
+    if (javaEmParamter) {
+        EMParameter = (jbyte *)env->GetByteArrayElements(javaEmParamter, NULL);
+        if (EMParameter == NULL) {
+            ALOGE("Error retrieving source of EM paramters");
+            return -2; // out of memory or no data to load
+        }
+    } else {
+        ALOGE("NULL java array of audio data to play, can't play");
+        return -2;
+    }
+    if(AudioSystem::GetEMParameter ((void *)buffer, len) != NO_ERROR ){
+        index =-1;
+    }
+
+    env->SetByteArrayRegion(javaEmParamter, 0, len, (const signed char*) buffer);
+    env->ReleaseByteArrayElements(javaEmParamter, EMParameter, JNI_ABORT);
+
+    return index;
+}
+
+// zormax add end
 
 // ----------------------------------------------------------------------------
 
@@ -1775,6 +1905,13 @@ static const JNINativeMethod gMethods[] = {
     {"getOutputLatency",    "(I)I",     (void *)android_media_AudioSystem_getOutputLatency},
     {"setLowRamDevice",     "(Z)I",     (void *)android_media_AudioSystem_setLowRamDevice},
     {"checkAudioFlinger",    "()I",     (void *)android_media_AudioSystem_checkAudioFlinger},
+    // add zormax, for em mode setting
+    {"setEmParameter",   "([BI)I",     (void *)android_media_AudioSystem_SetEMParameter},
+    {"getEmParameter",   "([BI)I",     (void *)android_media_AudioSystem_GetEMParameter},
+    {"setAudioCommand",   "(II)I",     (void *)android_media_AudioSystem_SetAudioCommandX},
+    {"getAudioCommand",   "(I)I",     (void *)android_media_AudioSystem_GetAudioCommandX},
+    {"setAudioData",            "(II[B)I",     (void *)android_media_AudioSystem_SetAudioData},
+    {"getAudioData",            "(II[B)I",     (void *)android_media_AudioSystem_GetAudioData},
     {"listAudioPorts",      "(Ljava/util/ArrayList;[I)I",
                                                 (void *)android_media_AudioSystem_listAudioPorts},
     {"createAudioPatch",    "([Landroid/media/AudioPatch;[Landroid/media/AudioPortConfig;[Landroid/media/AudioPortConfig;)I",
diff --git a/core/jni/fd_utils-inl.h b/core/jni/fd_utils-inl.h
index a68a602..5802057 100644
--- a/core/jni/fd_utils-inl.h
+++ b/core/jni/fd_utils-inl.h
@@ -59,6 +59,7 @@ static const char* kPathWhitelist[] = {
   "/dev/ion",
   "/dev/dri/renderD129", // Fixes b/31172436
   "/system/framework/org.cyanogenmod.platform-res.apk",
+  "/proc/ged",
 #ifdef PATH_WHITELIST_EXTRA_H
 PATH_WHITELIST_EXTRA_H
 #endif
@@ -306,7 +307,7 @@ class FileDescriptorInfo {
       return true;
     }
 
-    return false;
+    return true;
   }
 
   // TODO: Call android::base::Readlink instead of copying the code here.
diff --git a/media/java/android/media/AudioSystem.java b/media/java/android/media/AudioSystem.java
index e08c290..40a9674 100644
--- a/media/java/android/media/AudioSystem.java
+++ b/media/java/android/media/AudioSystem.java
@@ -823,5 +823,60 @@ public class AudioSystem
      * Keep in sync with core/jni/android_media_DeviceCallback.h.
      */
     final static int NATIVE_EVENT_ROUTING_CHANGE = 1000;
+    /// zormax: Add for support EM
+    /**
+     * Set EM parameter.
+     *
+     * @param ptr The data to be set.
+     * @param length The data size.
+     * @return The status.
+     */
+    public static native int setEmParameter(byte[] ptr, int length);
+
+    /**
+     * Get EM parameter.
+     *
+     * @param ptr The data to be get.
+     * @param length The data size.
+     * @return The status.
+     */
+    public static native int getEmParameter(byte[] ptr, int length);
+
+    /**
+     * Set audio command.
+     *
+     * @param arg1 The first argument.
+     * @param arg2 The second argument.
+     * @return The status.
+     */
+    public static native int setAudioCommand(int arg1, int arg2);
+
+    /**
+     * Get audio command.
+     *
+     * @param arg1 The first argument.
+     * @return The status.
+     */
+    public static native int getAudioCommand(int arg1);
+
+    /**
+     * Set audio data.
+     *
+     * @param par1 The par1.
+     * @param len The length.
+     * @param ptr The array of audio data.
+     * @return The status.
+     */
+    public static native int setAudioData(int par1, int len, byte[] ptr);
+
+    /**
+     * Get audio data.
+     *
+     * @param par1 The par1.
+     * @param len The length of data..
+     * @param ptr The array to receive audio data.
+     * @return The status.
+     */
+    public static native int getAudioData(int par1, int len, byte[] ptr);
 }
 
diff --git a/services/core/java/com/android/server/lights/LightsManager.java b/services/core/java/com/android/server/lights/LightsManager.java
index e1e5aa3..436d8b8 100644
--- a/services/core/java/com/android/server/lights/LightsManager.java
+++ b/services/core/java/com/android/server/lights/LightsManager.java
@@ -20,8 +20,8 @@ public abstract class LightsManager {
     public static final int LIGHT_ID_BACKLIGHT = 0;
     public static final int LIGHT_ID_KEYBOARD = 1;
     public static final int LIGHT_ID_BUTTONS = 2;
-    public static final int LIGHT_ID_BATTERY = 3;
-    public static final int LIGHT_ID_NOTIFICATIONS = 4;
+    public static final int LIGHT_ID_BATTERY = 4;
+    public static final int LIGHT_ID_NOTIFICATIONS = 3;
     public static final int LIGHT_ID_ATTENTION = 5;
     public static final int LIGHT_ID_BLUETOOTH = 6;
     public static final int LIGHT_ID_WIFI = 7;
diff --git a/services/core/java/com/android/server/notification/NotificationManagerService.java b/services/core/java/com/android/server/notification/NotificationManagerService.java
index c20b215..d8abf2d 100644
--- a/services/core/java/com/android/server/notification/NotificationManagerService.java
+++ b/services/core/java/com/android/server/notification/NotificationManagerService.java
@@ -120,6 +120,7 @@ import android.text.TextUtils;
 import android.util.ArrayMap;
 import android.util.ArraySet;
 import android.util.AtomicFile;
+import java.util.HashMap;
 import android.util.Log;
 import android.util.Slog;
 import android.util.SparseArray;
@@ -265,7 +266,7 @@ public class NotificationManagerService extends SystemService {
     private boolean mMultipleNotificationLeds;
     private boolean mMultipleLedsEnabledSetting = false;
 
-    private boolean mAutoGenerateNotificationColor = true;
+    private boolean mAutoGenerateNotificationColor = false; // zormax
 
     private boolean mScreenOnEnabled = false;
     private boolean mScreenOnDefault = false;
